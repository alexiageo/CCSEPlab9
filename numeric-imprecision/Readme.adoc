= Numeric Imprecision

//tag::abstract[]

Numeric Imprecision happens
when floating-point arithmetic or coercion result into
less accurate number which has significant impact on          
the context of the program.

//end::abstract[]

For example,
`double` is a double-precision 64-bit binary format IEEE
754 value and ranges between -(2^53^-1) and 2^53^-1).

Beyond this range, it is not safe to perform operations on the number as the
number will be approximation of the value. 
Furthermore, coercion of numbers that are not prime factor of 2
may result
into less accurate number because of rounding.

This issue can cause logic bypass and often
result in serious impact.

//tag::lab[]

== Lab

=== Task 0

Clone this repository.
Install `docker` and `make` on your system.

. Build the program: `make build`.
. Run it: `make run`.
. Run unit tests: `make test`.
. Run security tests: `make securitytest`.

[NOTE]
--
There are no security tests. You will write them later on.
--

=== Task 1

Review the program code and try to spot the vulnerability.

=== Task 2

The program is vulnerable to Numeric Imprecision.
Perform both run-time and static analysis to trigger and test for this vulnerability.

You can use the test data that has been shown in the slides (Slide number 70).

=== Task 3

Review `test/java/appSpec.java` and see how the tests work.
Your task is to write tests to test for edge cases that can trigger the vulnerability.

You should write the tests `test/java/appSecuritySpec.java` file. Use the comments as a guide, and feel free to write some extra tests if you can think of more edge cases.

[IMPORTANT]
--
The security tests you write should fail. You do not have to patch the program to make the tests pass (and subsequently fix the vulnerability) in this lab.
--

[NOTE]
--
Use the existing test code in `test/java/appSpec.java` as a guide. The libraries required for you are also already imported in `test/java/appSecuritySpec.java`. Google is your friend.
--

== Lab 10

[IMPORTANT]
--
Make sure you've completed Tasks 1-3 before attempting the remaining tasks!
--

For this lab, you should create a new branch for each task. If you're unfamiliar with how branching works in git, https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging[have a read of this].

=== Task 1

Patch the vulnerability in the program by applying the pre-condition check. You can use either a safe addition implementation, or a safe subtraction implementation, whichever makes sense. You may have to modify your security tests slightly (either just modify them, or remove a few redundant ones) depending on how you choose to write the patch.

=== Task 2

Patch the vulnerability in the program by applying an upcasting check. You may have to modify your security tests slightly (either just modify them, or remove a few redundant ones) depending on how you choose to write the patch.

=== Task 3

Patch the vulnerability in the program by using a dynamic type. You can use a built-in type, but it is highly recommended that you instead write your own dynamic type as a wrapper around the built-in type. If you want more work, then implement your own dynamic type from scratch without depending on any built-in types (except for the usual ones of course, i.e Strings, integers, longs, etc are all allowed). You will most definitely have to modify your security tests when you write this patch.

=== Task 4

Depending on how you've completed the previous three tasks, it may make sense to combine them all together (in some fashion). In this task, you should do just that: combine the patches from the previous three tasks into one. You will probably have to make modifications to your security tests again.

//end::lab[]

//tag::references[]

== References

* OWASP Application Security Verification Standard 4.0, 5.4.3
* CWE 190

//end::references[]

== License

See link:LICENSE[]
